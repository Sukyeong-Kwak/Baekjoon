// 2725_보이는_점의_개수(https://www.acmicpc.net/problem/2725)

// (0,0)에서 보이는 (x,y)의 개수를 구하려고 한다.(x,y >= 0, 정수)
// (0,0)에서 (x,y)가 보이려면 (0,0)과 (x,y)를 연결하는 직선이 다른 점을 통과하지 않아야 한다. 예를 들어 (4,2)는 
// (0,0)에서 보이지 않는다. 그 이유는 (0,0)과 (4,2)를 연결하는 직선이 (2,1)을 통과하기 때문이다. 아래 그림은 0 
// <= x,y<=5인 경우에 (0,0)에서 보이는 점의 개수이다. 단, (0,0)은 계산하지 않는다.

// 풀이
// 결국 기울기가 중복되지 않는 점들을 찾아야 했기 때문에 기울기를 모두 배열에 넣고 새로운 기울기를 비교해서 
// 판단할까 했다. 하지만 그렇게하면 매번 배열에 있는 값들과 비교해야해서 무조건 시간초과가 나올 것 같았다.
// (2,4), (3,15) 같은 이미 같은 기울기가 있는 좌표들은 모두 2나 3으로 나누어떨어진다. 그래서 x좌표와 y좌표의 
// 최대공약수가 1인 점들은 기울기가 중복되지 않는 점들이라고 판단할 수 있다고 생각했다.

// 최대공약수를 떠올리는 것은 그렇게 어렵지 않았지만 시간초과를 해결해는 것이 어려웠다.
// 전체 좌표의 절반정도를 최대공약수가 1인지 판별했다. 대략적으로 최대공약수가 1인 개수의 2를 곱해서 해당 개수를 
// 구했다. 하지만 이렇게 매번 계산을 하게되면 시간초과가 발생했다. 최대공약수 판별 함수도 바꿔보고 계산량을 조금
// 이라도 줄일 수 있는 방법들을 최대한 써봤지만 시간초과가 해결되지 않았다.

// 그래서 구글에서 찾아보니 대부분의 사람들이 점의 개수가 1~1000개까지 모든 경우의 수를 계산하여 배열에 저장한 후 
// 문제를 입력받은 숫자들에 해당하는 값을 배열에서 출력하는 방식으로 문제를 풀었다. 
// 이렇게 되면 점의 개수 1000개인 경우일 때의 계산량과 모든 결과를 배열에 저장할 때의 계산량이 거의 비슷하다. 
// 이렇게 푼적은 거의 없었는데 배열을 이용하니 이런 방법도 사용할 수 있다는 것을 알게 되었다.

#include <stdio.h>
#include <stdlib.h>

int lcm(int a, int b){
    int n = a, m = b, k = a%b;
    while (k != 0) {
        n = m; m = k; k = n%m;
    }
    return (m == 1);
}

int main() {
    int* arr = (int *)malloc(sizeof(int)*1000);
    arr[0] = 3;
    for (int i = 1; i < 1000; i++){
        int res = 0;
        for (int j = 1; j <= i; j++){
            if (((i+1)%2 + j%2) == 0) continue;
            else res += lcm(i+1,j);
        }
        
        arr[i] = arr[i-1] + res*2;
    }
    int t; scanf("%d", &t);
    for (int i = 0; i < t; i++){
        int n; scanf("%d", &n);
        printf("%d\n", arr[n-1]);
    }
}
